mod printf_internal;
mod printf;

extern fn print_int(x: i32) -> i32;
extern fn print_char(x: i32) -> i32;
extern fn debug_break();
extern fn rt_malloc<T>(i: u32) -> *T;
extern fn rt_abort() -> !;
fn print_uint(x: u32) { print_int(x as i32); }

fn sw_mul(x: u32, y: u32, is_signed: bool) -> u32 {
	let abs_x: u32 = x;
	let abs_y: u32 = y;
	let invert = false;
	if(is_signed){
		abs_x = if((x as i32) < 0){ ~x + 1 } else{ x };
		abs_y = if((y as i32) < 0){ ~y + 1 } else{ y };
		invert = ((x as i32) < 0) != ((y as i32) < 0);
	}
	let product: u32 = 0;
	while abs_y != 0 {
		if (abs_y & 1) != 0 {
			product = product + abs_x;
		}
		abs_x = abs_x << 1;
		abs_y = abs_y >> 1;
	}
	if invert {
		product = ~product + 1;
	}
	product
}

// compute x / y
fn sw_div(x: u32, y: u32, is_signed: bool) -> u32 {
	let abs_x: u32 = x;
	let abs_y: u32 = y;
	let invert = false;
	if(is_signed){
		abs_x = if((x as i32) < 0){ ~x + 1 } else{ x };
		abs_y = if((y as i32) < 0){ ~y + 1 } else{ y };
		invert = ((x as i32) < 0) != ((y as i32) < 0);
	}
	let quotient = 0;
	while(abs_x >= abs_y){
		quotient += 1;
		abs_x = abs_x - abs_y;
	}
	if(invert){
		quotient = ~quotient + 1;
	}
	quotient
}

// compute x % y
fn sw_mod(x: u32, y: u32, is_signed: bool) -> u32 {
	let abs_x: u32 = x;
	let abs_y: u32 = y;
	let invert = false;
	if(is_signed){
		abs_x = if((x as i32) < 0){ ~x + 1 } else{ x };
		abs_y = if((y as i32) < 0){ ~y + 1 } else{ y };
		invert = ((x as i32) < 0);
	}
	while(abs_x >= abs_y){
		abs_x = abs_x - abs_y;
	}
	if(invert){
		~abs_x + 1
	} else {
		abs_x
  }
}
